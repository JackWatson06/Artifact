package com.murdermaninc.main;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Toolkit;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

import com.mudermaninc.entity.GrassBoss;
import com.mudermaninc.entity.Player;
import com.murdermaninc.blocks.Block;
import com.murdermaninc.graphics.Background;
import com.murdermaninc.graphics.Font;
import com.murdermaninc.graphics.Screen;
import com.murdermaninc.level.Level;

@SuppressWarnings("serial")
public class Main extends Canvas implements Runnable{
	
	Dimension ScreenSize = Toolkit.getDefaultToolkit().getScreenSize();
	public final int width = (int) ScreenSize.getWidth();
	public final int height = (int) ScreenSize.getHeight();
	private boolean running = false;
	private Player player;
	private Level level;
	private InputManager input = new InputManager(this);
	private BufferedImage imageTiles = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	private int[] pixelsTiles = ((DataBufferInt) imageTiles.getRaster().getDataBuffer()).getData();
	private BufferedImage imagePlayer = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	private int[] pixelsPlayer = ((DataBufferInt) imagePlayer.getRaster().getDataBuffer()).getData();
	private BufferedImage imageMenu = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	private int[] pixelsMenu = ((DataBufferInt) imageMenu.getRaster().getDataBuffer()).getData();
	private static int tickCount = 0;
	private Screen screenTiles;
	private Screen screenPlayer;
	private Screen screenMenu;
	private Background background;
	private Background artifactBackground;
	private boolean tileUpdate = true;
	private boolean renderDecorationsOnce = true;
	private boolean dataReturn = false;
	public static boolean menu = false;
	private RenderTwo renderTwo = new RenderTwo();
	
	private GrassBoss grassboss;
	private boolean despawn = false;
	
	private void start(){
		running = true;
		Thread game = new Thread(this);
		game.start();
	}
	
	private void init(){
		screenPlayer = new Screen(width, height, 0, 0);
		screenMenu = new Screen(width, height, 0, 0);
		try {
			artifactBackground = new Background(ImageIO.read(Main.class.getResource("/ArtifactBackgroundFullScale - 4.png")));

		} catch (IOException e) {
			e.printStackTrace();
		}
		//player = new Player("Player", input, 64, screenPlayer.height - (64 * 3) + 1);
		player = new Player("Player", input, 64 + (17 * 4), 832 + (16 * 4));
		grassboss = new GrassBoss("Grass Boss", width / 2 - 128, 230, 1038, 1242);
	}
	
	
	public void run() {
		
		long lastTime = System.nanoTime();
		int desiredUPS = 1000;
		long nanoTimeTicks = (1000*1000*1000) / desiredUPS;
		int frames = 0;
		int ticks = 0;
		float gameSpeed = 60 / desiredUPS;
		long timePassedTicks = 0;
		long reset = System.nanoTime();
		boolean shouldRender = false;
		
		init();

		while(running){
			long now = System.nanoTime();
			timePassedTicks += (now - lastTime);
			lastTime = now;
			
			while(timePassedTicks >= nanoTimeTicks){
				ticks++;
				timePassedTicks = 0;
				tick(gameSpeed);
				shouldRender = true;
			
			}
			if(shouldRender){
				frames++;
				shouldRender = false;
				Thread render = new Thread(renderTwo);
				render.start();
				render();
			}
			
			if(System.nanoTime() - reset > (1000*1000*1000)){
				reset += (1000*1000*1000);
				System.out.println("Frames: " + frames + " Ticks: " + ticks);
				frames = 0;
				ticks = 0;
				}
			}
		
	}
	
	private void tick(float gameSpeed){
		
		player.resetButtons();
		
		if(level == null){
			loadLevel("Level3", "/scaledDownBackground.png");
		}
		
		tickCount++;
		
		player.tick(gameSpeed, tickCount);
		
		if(input.test){
			despawn = !despawn;
			input.test = false;
		}
		level.tick();

		//X Scrolling
		if(player.x + 31 >= width / 2 && player.movedD && !(level.levelWidth == 30)){
			if(screenTiles.screenX < screenTiles.width - width){
				screenTiles.screenX += player.currentSpeed;
				player.x = width / 2 - 31;
				if(screenTiles.screenX > screenTiles.width - width){
					int subtract = screenTiles.screenX - (screenTiles.width - width);
					screenTiles.screenX -= subtract;
				}
			}
		}
		
		if(player.x + 31 <= width / 2 && player.movedA && !(level.levelWidth == 30)){
			if(screenTiles.screenX > 0){
				screenTiles.screenX -= player.currentSpeed;
				player.x = width / 2 - 31;
				if(screenTiles.screenX < 0){
					int add = 0 - screenTiles.screenX;
					screenTiles.screenX += add;
				}
			}
		}
		
		//Y Scrolling
		if(player.y + 31 <= height / 2 && player.jump && !(level.levelHeight == 17)){
			if(screenTiles.screenY > 0){
			screenTiles.screenY -= player.currentJumpSpeed;
			player.y = height / 2 - 31;
			if(screenTiles.screenY < 0){
				int add = 0 - screenTiles.screenY;
				screenTiles.screenY += add;
				}
			}
		}
		
		if(player.y + 31 >= height / 2 && player.gravity && !(level.levelHeight == 17)){
			if(screenTiles.screenY < screenTiles.height - height){
			
			screenTiles.screenY += player.currentGravitySpeed;
			player.y = height / 2 - 31;
			
			if(screenTiles.screenY > screenTiles.height  - height){
				int subtract = screenTiles.screenY - (screenTiles.height - height);
				screenTiles.screenY -= subtract;
				}
			}
		}
		
		checkCollisions();
		
		level.touchingArtifact(screenTiles.screenX + player.x + 8, screenTiles.screenX + player.x + 63 - 8, screenTiles.screenY + player.y + 4, screenTiles.screenY + player.y + 63);

	}
	
	private void render(){ 
		//This Render method is reserved for renders to the screenPlayers screen
		BufferStrategy bs = getBufferStrategy();
		if(bs == null){
			createBufferStrategy(2);
			requestFocus();
			return;
		}
		if(!menu){		
			for(int i = 0; i < background.pixels.length; i++){
				screenPlayer.pixels[i] = background.pixels[i];
			}
		
			level.renderDecorationsAnimated();
		
			player.render(screenPlayer);
			if(!despawn){
				grassboss.render(screenPlayer);
			}
			
			for(int y = 0; y < height; y++){
				for(int x = 0; x < width; x++){
					pixelsPlayer[x + (y * width)] = screenPlayer.pixels[x + (y * width)];
				}
			}
		}
		
		Graphics g = bs.getDrawGraphics();
		if(!menu){
			g.drawImage(imagePlayer, 0, 0, width, height, null);
			g.drawImage(imageTiles, 0, 0, width, height, null);
		}else{
			g.drawImage(imageMenu, 0, 0, width, height, null);
		}
		g.dispose();
		bs.show();
		
		//System.out.println("Total Memory - KB: " + (Runtime.getRuntime().totalMemory()) / (1024));
		//System.out.println("Free Memory - KB: " + (Runtime.getRuntime().freeMemory()) / (1024));
		//System.out.println("Current Memory - KB: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024));
		
	}
	
	private void loadLevel(String loadLevel, String backgroundPath){
		level = new Level(loadLevel, this);
		screenTiles = level.getScreen();
		try{
			background = new Background(ImageIO.read(Main.class.getResource(backgroundPath)));
		}catch(IOException ioe){
			ioe.printStackTrace();
		}
		background.scaleImage(4, width, height);
		
	}
	
	public static int getTicks(){
		return tickCount;
	}
	
	private void checkCollisions(){
				
				int xTile = screenTiles.screenX + player.x;
				int yTile = screenTiles.screenY + player.y;
				int px = xTile + 8;
				int pxr = xTile + 63 - 8;
				int py = yTile + 4;
				int pyb = yTile + 63;
				
				boolean setUp = false;
				boolean setDown = false;
				boolean setLeft = false;
				boolean setRight = false;
				
				Block uL = level.getBlock((int)Math.floor(px / 64), (int) Math.floor(py / 64));
				Block uR = level.getBlock((int)Math.floor(pxr / 64), (int) Math.floor(py / 64));
				
				Block bL = level.getBlock((int)Math.floor(px / 64), (int) Math.floor(pyb / 64));
				Block bR = level.getBlock((int)Math.floor(pxr / 64), (int) Math.floor(pyb / 64));
		
				Block gL = level.getBlock((int)Math.floor(px  / 64), (int) Math.floor((pyb + 1) / 64));
				Block gR = level.getBlock((int)Math.floor(pxr / 64), (int) Math.floor((pyb + 1) / 64));
				if(player.movedD){
					 gL = level.getBlock((int)Math.floor((px - player.currentSpeed)  / 64), (int) Math.floor((pyb + 1) / 64));
					 gR = level.getBlock((int)Math.floor((pxr - player.currentSpeed) / 64), (int) Math.floor((pyb + 1) / 64));
				}else if(player.movedA){
					 gL = level.getBlock((int)Math.floor((px + player.currentSpeed)  / 64), (int) Math.floor((pyb + 1) / 64));
					 gR = level.getBlock((int)Math.floor((pxr + player.currentSpeed) / 64), (int) Math.floor((pyb + 1) / 64));
				}
				if((!gL.collisions && !gR.collisions) && !player.jump && !player.gravity){
					player.gravity = true;
					player.resetGravity(tickCount);
				}
				
				if(uR.collisions && !uL.collisions && !bL.collisions && !bR.collisions){
					if(pxr - player.currentSpeed <= uR.x * 64){
						setLeft = true;
						setDown = false;
						setUp = false;
					}else{
						setDown = true;
						setUp = false;
						setLeft = false;
					}
				}
				if(uL.collisions && !uR.collisions && !bL.collisions && !bR.collisions){
					if(px + player.currentSpeed >= (uL.x * 64) + 63){
						setRight = true;
						setDown = false;
						setUp = false;
					}else{
						setDown = true;
						setUp = false;
						setLeft = false;
					}
				}
				if(bL.collisions && !uR.collisions && !uL.collisions && !bR.collisions){
					if(px + player.currentSpeed >= (bL.x * 64) + 63){
						setRight = true;
						setDown = false;
						setUp = false;
					}else{
						setUp = true;
						setDown = false;
						setLeft = false;
					}
				}
				if(bR.collisions && !uL.collisions && !bL.collisions && !uR.collisions){
					if(pxr - player.currentSpeed <= bR.x * 64){
						setLeft = true;
						setDown = false;
						setUp = false;
					}else{
						setUp = true;
						setDown = false;
						setLeft = false;
					}
				}
				
				if(bL.collisions && bR.collisions){
					setUp = true;
					setLeft = false;
					setRight = false;
				}
				if(uL.collisions && uR.collisions){
					setDown = true;
					setLeft = false;
					setRight = false;
				}
				if(uR.collisions && bR.collisions){
					setLeft = true;
					setUp = false;
					setDown = false;
				}
				if(uL.collisions && bL.collisions){
					setRight = true;
					setUp = false;
					setDown = false;
				}
				if(uR.collisions && bL.collisions && player.gravity){
					setUp = true;
					setLeft = true;
				}
				if(uR.collisions && bL.collisions && player.jump){
					setDown = true;
					setRight = true;
				}
				if(uL.collisions && bR.collisions && player.gravity){
					setUp = true;
					setRight = true;
				}
				if(uL.collisions && bR.collisions && player.jump){
					setDown = true;
					setLeft = true;
				}
				
				boolean data = false;
				if(data){
					System.out.println("UboveL: " + uL);
					System.out.println("UboveR: " + uR);
					System.out.println();
					System.out.println("BelowL: " + bL);
					System.out.println("BelowR: " + bR);
					System.out.println();
					System.out.println("GravityL: " + gL);
					System.out.println("GravityR: " + gR);
					System.out.println(tickCount);
				}
				if(dataReturn){
					running = false;
				}
				
				if(setDown){
					if(screenTiles.screenY > 0 && screenTiles.screenY < screenTiles.height - height){
						player.y = height / 2 - 31;
						player.jump = false;
						input.jump = false;
						int add = (uR.y * 64 + 64) - py;
						screenTiles.screenY += add;
					}else{
						player.y = (uR.y * 64) - screenTiles.screenY + 60;
						player.jump = false;
						input.jump = false;
					}
					
				}
				if(setUp){
					if(screenTiles.screenY > 0 && screenTiles.screenY < screenTiles.height - height){
						player.y = height / 2 - 31;
						input.jumpAvailability = true;
						player.gravity = false;
						int subtract = (pyb - bL.y * 64) + 1;
						screenTiles.screenY -= subtract;
					}else{
						player.y = (bR.y * 64) - screenTiles.screenY - 64;
						input.jumpAvailability = true;
						player.gravity = false;
					}
				}
				if(setLeft){
					if(screenTiles.screenX > 0 && screenTiles.screenX < screenTiles.width - width){
						player.x = width / 2 - 31;
						int subtract = (pxr + 1) - uR.x * 64;
						System.out.println("Subtract: " + subtract);
						screenTiles.screenX -= subtract;
					}else{
						player.x = (uR.x * 64) - screenTiles.screenX - 56;
					}
				}
				if(setRight){
					if(screenTiles.screenX > 0 && screenTiles.screenX < screenTiles.width - width){
						player.x = width / 2 - 31;
						int add = (uL.x * 64 + 64) - px;
						screenTiles.screenX += add;
					}else{
						player.x = (uL.x * 64) - screenTiles.screenX + 56;
					}
				}
	}
	
	
	
	public static void main(String[] args){
		Main game = new Main();
		
		JFrame frame = new JFrame();
		frame.setResizable(false);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
		frame.setUndecorated(true);
		frame.setLayout(new BorderLayout());
		frame.add(game, BorderLayout.CENTER);
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
		
		game.start();
		
	}
	
	class RenderTwo implements Runnable{

		public void run() {
			//This render method is strictly for renders to the screenTile class and also menu classes
			if(!menu){
				level.resetDecorations();

				if(tileUpdate){
					level.renderBlocks();
					tileUpdate = false;
				}
				if(renderDecorationsOnce){
					level.renderDecorations();
					renderDecorationsOnce = false;
				}
				
				Font.drawText(screenTiles, "(Testing)" + level.name, ((width / 2) - (Font.getTextLength("(Testing)" + level.name, 2) / 2)), 10, 2);
				
				int leftOverHeight = screenTiles.screenX + (screenTiles.screenY * screenTiles.width);	
				for(int y = 0; y < height; y++){
					for(int x = 0; x < width; x++){
						pixelsTiles[x + (y * width)] = screenTiles.pixels[leftOverHeight + (x + (y * (screenTiles.width)))];
					}
				}

			}
			if(menu){
				for(int i = 0; i < artifactBackground.scaledDown.length; i++){
					screenMenu.pixels[i] = artifactBackground.scaledDown[i];
				}
				screenMenu.render((width / 2) - ((16 * 40) / 2), (height / 2) - ((16 * 40) / 2), level.currentArtifact().xTile, level.currentArtifact().yTile, 40);
				
				for(int i = 0; i < 12; i++){
					screenMenu.render((width / 2) - (((16 * 12) * 6) / 2) + (i * (16 * 6)), 60, i, 12, 6);
				}
				
				Font.drawText(screenMenu, level.currentArtifact().name, (width / 2) - (Font.getTextLength(level.currentArtifact().name, 4) / 2), height - (96 + 60), 4);
				for(int y = 0; y < height; y++){
					for(int x = 0; x < width; x++){
						pixelsMenu[x + (y * width)] = screenMenu.pixels[x + (y * width)];
					}
				}
			}
		}
		
	}
	
	
	
}
